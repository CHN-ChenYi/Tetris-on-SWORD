# 子模块

* 消行
  * 输入
    * 板上时钟 // 需要吗？还是直接 always@* / 组合逻辑电路？
    * 当前静止块的游戏局面
  * 输出
    * 是否有消行
    * 消行后游戏局面
  * 行为
    * 只消一行
    * 一个周期就可完成
* 旋转
  * 输入
    * 当前浮动模块状态
    * 旋转方向（0 顺时针，1 逆时针）
  * 输出
    * 旋转后的浮动模块状态
  * 行为
    * 组合逻辑电路
* 判断碰撞
  * 输入
    * 板上时钟 // 需要吗？还是直接 always@* / 组合逻辑电路？
    * 当前浮动模块状态
    * 当前静止块的游戏局面
    * 锚点位置
  * 输出
    * 是否有重合
  * 行为
    * 一个周期即可完成
* 组合
  * 输入
    * 当前静止块的游戏局面
    * 当前浮动模块状态
    * 锚点位置
  * 输出
    * 合并之后的游戏局面
  * 行为
    * 一个周期即可完成
* 显示
  * 输入
    * 当前游戏局面（组合模块的输出）
    * vga 所需的必要的线
    * 游戏是否结束？
  * 输出
    * vga 所需的必要的线
* 判断游戏是否结束
  * 输入
    * 当前静止块的游戏局面
    * 当前浮动模块状态
    * 锚点位置
  * 输出
    * 是否死亡（1为死）

# Top

* 用户时钟
  * mode 改为 1
  * 通过随机模块结果更新浮动模块

* 逻辑时钟串行部分行为（通过 mode 实现串行）
  * 如有旋转
    * 看判断碰撞模块一（输入为旋转模块的输出）的输出，若可行，更新浮动模块
  * 如有左右移动
    * 看判断碰撞模块二/三（输入为当前锚点左移一个/右移一个）的输出，若可行，更新锚点
  * 向下移动
    * 看判断碰撞模块四（输入为当前锚点下移一个）的输出，若可行，更新锚点
  * 如有空格（加速向下） * 25（重复25遍）
    * 看判断碰撞模块四（输入为当前锚点下移一个）的输出，若可行，更新锚点
  * 更新静止模块
    * 组合模块的输出赋值给静止局面的reg，锚点移至画面外
  * 消行 * 4
    * 看消行模块输出，若可行，更新静止局面的reg，同时cnt++
  * 更新分数
    * cnt 输入到分数显示里面
  * 判断死亡
    * 若判断游戏是否结束模块输出死亡，则更新游戏

* 显示
  * 组合模块的输出 + 当前游戏是否死亡 输入给显示模块
